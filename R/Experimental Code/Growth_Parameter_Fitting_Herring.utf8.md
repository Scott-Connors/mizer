---
title: "Growth Parameter Fitting Herring"
author: "Richard Southwell"
date: "21 July 2017"
output: html_document
---



## Outline

In his VB paper Mike used empirical data $x = \{ (a_i,l_i) : i \in \{1,..,N \} \}$ where $a_i$ is number of winters that the $i$th fish caught has survived, and $l_i$ is this fish's length.

Our model has $12$ species, but we shall only speak here about varying the parameters for herring.

In this report we focus on sampling from the posterior $p(\theta|k,F_x(.)),$ where $\theta =(h,\gamma)$ are the growth parameters we shall run mizer with to generate simulated (age,length) data $m_E(\theta) = \{ (a_i ^*,l_i ^*) : i \in \{1,..,M \} \}$, where, currently, $a_i ^* = i \times \Delta t,$ and $l_i ^*,$ is mizer's prediction of the length of an age $a_i ^*$ Herring. Here $w_i ^* = \alpha \times (l_i ^*)^\beta,$ is the weight mizer predicts, by solving the equation $\frac{dw}{dt}=g(w,t),$ using the growth rates $g(w,t)$ generated by mizer as it evolves, under dynamic fishing efforts $E$ from years 1966 to 2010, as used in Mike's earlier paper on mizer. I suggest creating realistic initial conditions by starting from any initial size-spectrum-state and running the thing with efforts $E$ repeating end-to-end over time until the mizer dynamics go into a periodic orbit of the same period as $E.$

We write $k$ as shorthand to denote the von Bertalanffy (VB) parameters $k = (K,l_{\infty},t_0)$ corresponding to the VG growth model.

In previous work mike generated samples from $p(k|x),$ these give us an estimate $F_x(k) \approx p(k|x)$ of the posterior distribution of the VB parameters $k,$ given the empirical landings data $x.$ 

We wish to sample from $p(\theta|k,F_x(.)),$ which is the posterior distribution of the parameter $\theta,$ given VB parameters $k,$ under the assumption that $k$ is distributed according to distribution $F_x$ that was constructed using the empirical data $x.$

According to Bayes theorem $p(\theta|k,F_x(.)) \propto p(\theta)p(k|\theta,F_x(.)),$ 
where the likelihood can be rewritten as $$p(k|\theta,F_x(.)) = F_x(k_{best}[m(\theta)]),$$ where $k_{best}[m(\theta)])$ consists of the VB parameters that best fit the (age,length) data $m(\theta)$ which mizer generated.

So we write our target posterior distribution as 

$$p(\theta|k,F_x()) \propto p(\theta) F_x(k_{best}[m(\theta)])$$
At the moment I am using improper priors, and sampling using MCMC.

## Code

The code needs to be pasted


```r
source("./R/Experimental Code/growth with t0 and variable h.R")
```

(copy and paste into console).


```r
library(devtools)
library(ggplot2)
library(grid)
library(methods)
library(plyr)
library(reshape2)
library(mizer)
library(deSolve)
library(mvtnorm)
params_data <- read.csv("./vignettes/NS_species_params.csv")
inter <- read.csv("./vignettes/inter.csv", row.names=1)
inter <- as(inter, "matrix")
load("Herring.Rdata")
#out is name of this data = (k, Linf (in milimeters!),t0,sigma) 
```

We also specify the length to weight conversion constants $\alpha$ and $\beta$ and `mtimes` which are the time steps we shall generate the (age,length) data over.


```r
a <- 0.006
b <- 3.05
mytimes <- seq(0,100,0.1)
```

We take mike's samples and re-scale the length to convert it from mm to cm.


```r
out2 <- out
out2[,2] <- out[,2]/10
SIGMA<-cov(out2[,1:3])
MU<-colMeans(out2[,1:3])
```

Here `out2` is a list of mike's samples $(K,l_\infty,t_0)=k$ from $p(k|x).$


Here $\mu$ and $\Sigma$ are used to make a multivariate normal distribution $F_x(.)$ which we shall use to approximate mike's posterior distribution (probably we will use kernel density estimation instead, in the long term).

We shall go through the code used to estimate the likelihood $p(\theta|k,F_x(.))$ where the parameters $\theta$ used are the defaults hard wired into mizer.

Choose parameters and build the appropriate params object, and run mizer.


```r
params_dataA <- params_data
params_dataA[["h"]] <- param1@species_params[,14]
params_dataA[["gamma"]] <- param1@species_params[,15]
params_dataA[["w_inf"]] <- params_data[["w_inf"]]
param1A <- MizerParams(params_dataA, interaction = inter, no_w = 100)
testA<-project(param1A,effort=0.5,t_max = 3, dt = 0.25, t_save = 1)
ns <- dim(testA@n)[2]
naa <- testA@n[dim(testA@n)[1],,]
```

Extract growth rates


```r
gg <- getEGrowth(param1A, testA@n[dim(testA@n)[1],,], testA@n_pp[dim(testA@n_pp)[1],])
```

Get time vs weight curves for the different species by filling out growth rate points using an interpolator, and then solving ODE's. At the moment I am using the static growth rate associated with the final state, but this needs to be improved.




```r
weightsA <- matrix(0,nrow=length(mytimes),ncol=dim(testA@n)[2])
for (i in (1:ns)){
  gini <- approxfun(param1A@w, gg[i,])
  
  myodefun <- function(t, state, parameters){
    return(list(gini(state)))
  }
  weightsA[,i] <- ode(y = param1@w[1], times = mytimes, func = myodefun, parms = 1)[,2]
}
```

Convert from weight to length


```r
lengthsA <- sapply(weightsA[,4],function(x) exp(log(x/a)/b))
```

Find best fit VB parameters $k_{best}[m(\theta)]$ to data


```r
datsA <- data.frame(X=mytimes, Y= lengthsA)
vbTyp<-function(X,Linf,k,t0){(Linf*(1-exp(-k*(X-t0))))}
obs_k <- MU[[1]]
obs_Linf <- MU[[2]]
obs_t0 <- MU[[3]]
fitTypA<-nls(Y~vbTyp(X,Linf,k,t0),data=datsA,start=list(Linf=obs_Linf,k=obs_k,t0=obs_t0))
vbfitA <- coef(fitTypA)
```

Determine likelihood $p(k|\theta,F_x(.)) \approx F_x(k_{best}[m(\theta)])$


```r
loglikeA <- dmvnorm(c(vbfitA[["k"]],vbfitA[["Linf"]],vbfitA[["t0"]]),MU,SIGMA,log=T)
loglikeA
```

An algorithm to generate likelihood for variable $h_{herring}$ (default is 35)


```r
loglikk <- function(hherring){
  hB <- param1@species_params[,14]
  hB[4] <- hherring
  #actual val encoded in mizer is 35.03807
  params_dataB <- params_data
  params_dataB[["h"]] <- hB
  params_dataB[["gamma"]] <- param1@species_params[,15]
  param1B <- MizerParams(params_dataB, interaction = inter, no_w = 100)
  testB<-project(param1B,effort=0.5,t_max = 3, dt = 0.25, t_save = 1)
  ns <- dim(testB@n)[2]
  nbb <- testB@n[dim(testB@n)[1],,]
  ggB <- getEGrowth(param1B, testB@n[dim(testB@n)[1],,], testB@n_pp[dim(testB@n_pp)[1],])
  sols <- as.list(1:ns)
  weightsB <- matrix(0,nrow=length(mytimes),ncol=dim(testB@n)[2])
  for (i in (1:ns)){
    gini <- approxfun(param1B@w, ggB[i,])
    myodefun <- function(t, state, parameters){
      return(list(gini(state)))
    }
    weightsB[,i] <- ode(y = param1B@w[1], times = mytimes, func = myodefun, parms = 1)[,2]
  }
  lengthsB <- sapply(weightsB[,4],function(x) exp(log(x/a)/b))
  datsB <- data.frame(X=mytimes, Y= lengthsB)
  vbTyp<-function(X,Linf,k,t0){(Linf*(1-exp(-k*(X-t0))))}
  obs_k <- MU[[1]]
  obs_Linf <- MU[[2]]
  obs_t0 <- MU[[3]]
  fitTypB<-nls(Y~vbTyp(X,Linf,k,t0),data=datsB,start=list(Linf=obs_Linf,k=obs_k,t0=obs_t0))
  vbfitB <- coef(fitTypB)
  loglikeB <- dmvnorm(c(vbfitB[["k"]],vbfitB[["Linf"]],vbfitB[["t0"]]),MU,SIGMA,log=T)
  return(loglikeB)
  }
#loglikk(params_data[["w_inf"]][4])
loglikk(10)
```

Calculate likelihoods for different h vals.

```r
loglikevec <- 1:7
for (i in (2:8)){
  loglikevec[i-1] <- loglikk(i*10)
}
h_herring <- (2:8)*10
```

Plot them


```r
plot(h_herring,loglikevec)
```

## Notes


I think mike's previous work assumed $t0=0$, so perhaps we should re-adjust our growth curves so that fish begin to grow at size zero. Or fit $t0$ as well.  I was wondering if we need to make the assumption that t0 =0. If this case the VB parameter fitting will work under the assumption that the fish is size 0 at age 0. However, to correspond to this, we should need to simulate how fish grow from size 0 in mizer. The issue is, I think it could be hard to get the growth rates for fish below egg size, as mizer is not designed to work in that regime, and it does not make as much physical sense to try and model the feeding habits of sub-egg-sized fish. I wonder if one way around this would be to also include t0 as an extra parameter we should fit (I guess I can do this using column 3 of herring.Rdata). Currently my mizer-generated time vs length plots work under the assumption that the fish is egg sized at t=0.

I need to include dynamic growth rates, include fitting of t0, and setup MCMC, and run it for herring.

Need to write a data frame that stores lots of useful objects when it runs sim. Make it so I can store data and run again cheaply.
